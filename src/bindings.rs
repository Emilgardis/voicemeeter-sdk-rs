/* automatically generated by rust-bindgen 0.68.1 */

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(unsafe_op_in_unsafe_fn)]
#![allow(deref_nullptr)]
#![allow(clippy::missing_safety_doc)]
#![allow(non_snake_case)]

pub const VBVMR_RESULT_OK: u32 = 0;
pub const expected_size_T_VBAN_VMRT_PACKET: u32 = 1384;
impl VBVMR_DEVTYPE {
    pub const MME: VBVMR_DEVTYPE = VBVMR_DEVTYPE(1);
}
impl VBVMR_DEVTYPE {
    pub const WDM: VBVMR_DEVTYPE = VBVMR_DEVTYPE(3);
}
impl VBVMR_DEVTYPE {
    pub const KS: VBVMR_DEVTYPE = VBVMR_DEVTYPE(4);
}
impl VBVMR_DEVTYPE {
    pub const ASIO: VBVMR_DEVTYPE = VBVMR_DEVTYPE(5);
}
#[repr(transparent)]
#[doc = " @name Device Enumeration Functions\n @{"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct VBVMR_DEVTYPE(pub ::std::os::raw::c_int);
#[doc = " @name VB-Audio Callback Functions\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagVBVMR_AUDIOINFO {
    pub samplerate: ::std::os::raw::c_long,
    pub nbSamplePerFrame: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_tagVBVMR_AUDIOINFO() {
    const UNINIT: ::std::mem::MaybeUninit<tagVBVMR_AUDIOINFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tagVBVMR_AUDIOINFO>(),
        8usize,
        concat!("Size of: ", stringify!(tagVBVMR_AUDIOINFO))
    );
    assert_eq!(
        ::std::mem::align_of::<tagVBVMR_AUDIOINFO>(),
        4usize,
        concat!("Alignment of ", stringify!(tagVBVMR_AUDIOINFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samplerate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_AUDIOINFO),
            "::",
            stringify!(samplerate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbSamplePerFrame) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_AUDIOINFO),
            "::",
            stringify!(nbSamplePerFrame)
        )
    );
}
#[doc = " @name VB-Audio Callback Functions\n @{"]
pub type VBVMR_T_AUDIOINFO = tagVBVMR_AUDIOINFO;
#[doc = " @name VB-Audio Callback Functions\n @{"]
pub type VBVMR_PT_AUDIOINFO = *mut tagVBVMR_AUDIOINFO;
#[doc = " @name VB-Audio Callback Functions\n @{"]
pub type VBVMR_LPT_AUDIOINFO = *mut tagVBVMR_AUDIOINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagVBVMR_AUDIOBUFFER {
    pub audiobuffer_sr: ::std::os::raw::c_long,
    pub audiobuffer_nbs: ::std::os::raw::c_long,
    pub audiobuffer_nbi: ::std::os::raw::c_long,
    pub audiobuffer_nbo: ::std::os::raw::c_long,
    pub audiobuffer_r: [*mut f32; 128usize],
    pub audiobuffer_w: [*mut f32; 128usize],
}
#[test]
fn bindgen_test_layout_tagVBVMR_AUDIOBUFFER() {
    const UNINIT: ::std::mem::MaybeUninit<tagVBVMR_AUDIOBUFFER> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tagVBVMR_AUDIOBUFFER>(),
        2064usize,
        concat!("Size of: ", stringify!(tagVBVMR_AUDIOBUFFER))
    );
    assert_eq!(
        ::std::mem::align_of::<tagVBVMR_AUDIOBUFFER>(),
        8usize,
        concat!("Alignment of ", stringify!(tagVBVMR_AUDIOBUFFER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audiobuffer_sr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_AUDIOBUFFER),
            "::",
            stringify!(audiobuffer_sr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audiobuffer_nbs) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_AUDIOBUFFER),
            "::",
            stringify!(audiobuffer_nbs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audiobuffer_nbi) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_AUDIOBUFFER),
            "::",
            stringify!(audiobuffer_nbi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audiobuffer_nbo) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_AUDIOBUFFER),
            "::",
            stringify!(audiobuffer_nbo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audiobuffer_r) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_AUDIOBUFFER),
            "::",
            stringify!(audiobuffer_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audiobuffer_w) as usize - ptr as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_AUDIOBUFFER),
            "::",
            stringify!(audiobuffer_w)
        )
    );
}
pub type VBVMR_T_AUDIOBUFFER = tagVBVMR_AUDIOBUFFER;
pub type VBVMR_PT_AUDIOBUFFER = *mut tagVBVMR_AUDIOBUFFER;
pub type VBVMR_LPT_AUDIOBUFFER = *mut tagVBVMR_AUDIOBUFFER;
#[doc = "@brief VB-AUDIO Callback is called for different task to Initialize, perform and end your process.\nVB-AUDIO Callback is part of single TIME CRITICAL Thread.\nVB-AUDIO Callback is non re-entrant (cannot be called while in process)\nVB-AUDIO Callback is supposed to be REAL TIME when called to process buffer.\n(it means that the process has to be performed as fast as possible, waiting cycles are forbidden.\ndo not use O/S synchronization object, even Critical_Section can generate waiting cycle. Do not use\nsystem functions that can generate waiting cycle like display, disk or communication functions for example).\n\n@param lpUser: User pointer given on callback registration.\n@param ncommand: reason why the callback is called.\n@param lpData: pointer on structure, pending on nCommand.\n@param nnn: additional data, unused\n\n@return :\t 0: always 0 (unused)."]
pub type T_VBVMR_VBAUDIOCALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        lpUser: *mut ::std::os::raw::c_void,
        nCommand: ::std::os::raw::c_long,
        lpData: *mut ::std::os::raw::c_void,
        nnn: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long,
>;
impl VBVMR_CBCOMMAND {
    pub const STARTING: VBVMR_CBCOMMAND = VBVMR_CBCOMMAND(1);
}
impl VBVMR_CBCOMMAND {
    pub const ENDING: VBVMR_CBCOMMAND = VBVMR_CBCOMMAND(2);
}
impl VBVMR_CBCOMMAND {
    pub const CHANGE: VBVMR_CBCOMMAND = VBVMR_CBCOMMAND(3);
}
impl VBVMR_CBCOMMAND {
    pub const BUFFER_IN: VBVMR_CBCOMMAND = VBVMR_CBCOMMAND(10);
}
impl VBVMR_CBCOMMAND {
    pub const BUFFER_OUT: VBVMR_CBCOMMAND = VBVMR_CBCOMMAND(11);
}
impl VBVMR_CBCOMMAND {
    pub const BUFFER_MAIN: VBVMR_CBCOMMAND = VBVMR_CBCOMMAND(20);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct VBVMR_CBCOMMAND(pub ::std::os::raw::c_int);
impl VBVMR_AUDIOCALLBACK {
    pub const INPUT: VBVMR_AUDIOCALLBACK = VBVMR_AUDIOCALLBACK(1);
}
impl VBVMR_AUDIOCALLBACK {
    pub const OUTPUT: VBVMR_AUDIOCALLBACK = VBVMR_AUDIOCALLBACK(2);
}
impl VBVMR_AUDIOCALLBACK {
    pub const MAIN: VBVMR_AUDIOCALLBACK = VBVMR_AUDIOCALLBACK(4);
}
impl ::std::ops::BitOr<VBVMR_AUDIOCALLBACK> for VBVMR_AUDIOCALLBACK {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        VBVMR_AUDIOCALLBACK(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for VBVMR_AUDIOCALLBACK {
    #[inline]
    fn bitor_assign(&mut self, rhs: VBVMR_AUDIOCALLBACK) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<VBVMR_AUDIOCALLBACK> for VBVMR_AUDIOCALLBACK {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        VBVMR_AUDIOCALLBACK(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for VBVMR_AUDIOCALLBACK {
    #[inline]
    fn bitand_assign(&mut self, rhs: VBVMR_AUDIOCALLBACK) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct VBVMR_AUDIOCALLBACK(pub ::std::os::raw::c_int);
impl VBVMR_MACROBUTTON_MODE {
    pub const DEFAULT: VBVMR_MACROBUTTON_MODE = VBVMR_MACROBUTTON_MODE(0);
}
impl VBVMR_MACROBUTTON_MODE {
    pub const STATEONLY: VBVMR_MACROBUTTON_MODE = VBVMR_MACROBUTTON_MODE(2);
}
impl VBVMR_MACROBUTTON_MODE {
    pub const TRIGGER: VBVMR_MACROBUTTON_MODE = VBVMR_MACROBUTTON_MODE(3);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct VBVMR_MACROBUTTON_MODE(pub ::std::os::raw::c_int);
pub type T_VBVMR_Login = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_long>;
pub type T_VBVMR_Logout = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_long>;
pub type T_VBVMR_RunVoicemeeter = ::std::option::Option<
    unsafe extern "C" fn(vType: ::std::os::raw::c_long) -> ::std::os::raw::c_long,
>;
pub type T_VBVMR_GetVoicemeeterType = ::std::option::Option<
    unsafe extern "C" fn(pType: *mut ::std::os::raw::c_long) -> ::std::os::raw::c_long,
>;
pub type T_VBVMR_GetVoicemeeterVersion = ::std::option::Option<
    unsafe extern "C" fn(pVersion: *mut ::std::os::raw::c_long) -> ::std::os::raw::c_long,
>;
pub type T_VBVMR_IsParametersDirty =
    ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_long>;
pub type T_VBVMR_GetParameterFloat = ::std::option::Option<
    unsafe extern "C" fn(
        szParamName: *mut ::std::os::raw::c_char,
        pValue: *mut f32,
    ) -> ::std::os::raw::c_long,
>;
pub type T_VBVMR_GetParameterStringA = ::std::option::Option<
    unsafe extern "C" fn(
        szParamName: *mut ::std::os::raw::c_char,
        szString: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long,
>;
pub type T_VBVMR_GetParameterStringW = ::std::option::Option<
    unsafe extern "C" fn(
        szParamName: *mut ::std::os::raw::c_char,
        wszString: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_long,
>;
pub type T_VBVMR_GetLevel = ::std::option::Option<
    unsafe extern "C" fn(
        nType: ::std::os::raw::c_long,
        nuChannel: ::std::os::raw::c_long,
        pValue: *mut f32,
    ) -> ::std::os::raw::c_long,
>;
pub type T_VBVMR_GetMidiMessage = ::std::option::Option<
    unsafe extern "C" fn(
        pMIDIBuffer: *mut ::std::os::raw::c_uchar,
        nbByteMax: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long,
>;
pub type T_VBVMR_SetParameterFloat = ::std::option::Option<
    unsafe extern "C" fn(
        szParamName: *mut ::std::os::raw::c_char,
        Value: f32,
    ) -> ::std::os::raw::c_long,
>;
pub type T_VBVMR_SetParameters = ::std::option::Option<
    unsafe extern "C" fn(szParamScript: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_long,
>;
pub type T_VBVMR_SetParametersW = ::std::option::Option<
    unsafe extern "C" fn(szParamScript: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long,
>;
pub type T_VBVMR_SetParameterStringA = ::std::option::Option<
    unsafe extern "C" fn(
        szParamName: *mut ::std::os::raw::c_char,
        szString: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long,
>;
pub type T_VBVMR_SetParameterStringW = ::std::option::Option<
    unsafe extern "C" fn(
        szParamName: *mut ::std::os::raw::c_char,
        wszString: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_long,
>;
pub type T_VBVMR_Output_GetDeviceNumber =
    ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_long>;
pub type T_VBVMR_Output_GetDeviceDescA = ::std::option::Option<
    unsafe extern "C" fn(
        zindex: ::std::os::raw::c_long,
        nType: *mut ::std::os::raw::c_long,
        szDeviceName: *mut ::std::os::raw::c_char,
        szHardwareId: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long,
>;
pub type T_VBVMR_Output_GetDeviceDescW = ::std::option::Option<
    unsafe extern "C" fn(
        zindex: ::std::os::raw::c_long,
        nType: *mut ::std::os::raw::c_long,
        wszDeviceName: *mut ::std::os::raw::c_ushort,
        wszHardwareId: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_long,
>;
pub type T_VBVMR_Input_GetDeviceNumber =
    ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_long>;
pub type T_VBVMR_Input_GetDeviceDescA = ::std::option::Option<
    unsafe extern "C" fn(
        zindex: ::std::os::raw::c_long,
        nType: *mut ::std::os::raw::c_long,
        szDeviceName: *mut ::std::os::raw::c_char,
        szHardwareId: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long,
>;
pub type T_VBVMR_Input_GetDeviceDescW = ::std::option::Option<
    unsafe extern "C" fn(
        zindex: ::std::os::raw::c_long,
        nType: *mut ::std::os::raw::c_long,
        wszDeviceName: *mut ::std::os::raw::c_ushort,
        wszHardwareId: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_long,
>;
pub type T_VBVMR_AudioCallbackRegister = ::std::option::Option<
    unsafe extern "C" fn(
        mode: ::std::os::raw::c_long,
        pCallback: T_VBVMR_VBAUDIOCALLBACK,
        lpUser: *mut ::std::os::raw::c_void,
        szClientName: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long,
>;
pub type T_VBVMR_AudioCallbackStart =
    ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_long>;
pub type T_VBVMR_AudioCallbackStop =
    ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_long>;
pub type T_VBVMR_AudioCallbackUnregister =
    ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_long>;
pub type T_VBVMR_MacroButton_IsDirty =
    ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_long>;
pub type T_VBVMR_MacroButton_GetStatus = ::std::option::Option<
    unsafe extern "C" fn(
        nuLogicalButton: ::std::os::raw::c_long,
        pValue: *mut f32,
        bitmode: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long,
>;
pub type T_VBVMR_MacroButton_SetStatus = ::std::option::Option<
    unsafe extern "C" fn(
        nuLogicalButton: ::std::os::raw::c_long,
        fValue: f32,
        bitmode: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagVBVMR_INTERFACE {
    pub VBVMR_Login: T_VBVMR_Login,
    pub VBVMR_Logout: T_VBVMR_Logout,
    pub VBVMR_RunVoicemeeter: T_VBVMR_RunVoicemeeter,
    pub VBVMR_GetVoicemeeterType: T_VBVMR_GetVoicemeeterType,
    pub VBVMR_GetVoicemeeterVersion: T_VBVMR_GetVoicemeeterVersion,
    pub VBVMR_IsParametersDirty: T_VBVMR_IsParametersDirty,
    pub VBVMR_GetParameterFloat: T_VBVMR_GetParameterFloat,
    pub VBVMR_GetParameterStringA: T_VBVMR_GetParameterStringA,
    pub VBVMR_GetParameterStringW: T_VBVMR_GetParameterStringW,
    pub VBVMR_GetLevel: T_VBVMR_GetLevel,
    pub VBVMR_GetMidiMessage: T_VBVMR_GetMidiMessage,
    pub VBVMR_SetParameterFloat: T_VBVMR_SetParameterFloat,
    pub VBVMR_SetParameters: T_VBVMR_SetParameters,
    pub VBVMR_SetParametersW: T_VBVMR_SetParametersW,
    pub VBVMR_SetParameterStringA: T_VBVMR_SetParameterStringA,
    pub VBVMR_SetParameterStringW: T_VBVMR_SetParameterStringW,
    pub VBVMR_Output_GetDeviceNumber: T_VBVMR_Output_GetDeviceNumber,
    pub VBVMR_Output_GetDeviceDescA: T_VBVMR_Output_GetDeviceDescA,
    pub VBVMR_Output_GetDeviceDescW: T_VBVMR_Output_GetDeviceDescW,
    pub VBVMR_Input_GetDeviceNumber: T_VBVMR_Input_GetDeviceNumber,
    pub VBVMR_Input_GetDeviceDescA: T_VBVMR_Input_GetDeviceDescA,
    pub VBVMR_Input_GetDeviceDescW: T_VBVMR_Input_GetDeviceDescW,
    pub VBVMR_AudioCallbackRegister: T_VBVMR_AudioCallbackRegister,
    pub VBVMR_AudioCallbackStart: T_VBVMR_AudioCallbackStart,
    pub VBVMR_AudioCallbackStop: T_VBVMR_AudioCallbackStop,
    pub VBVMR_AudioCallbackUnregister: T_VBVMR_AudioCallbackUnregister,
    pub VBVMR_MacroButton_IsDirty: T_VBVMR_MacroButton_IsDirty,
    pub VBVMR_MacroButton_GetStatus: T_VBVMR_MacroButton_GetStatus,
    pub VBVMR_MacroButton_SetStatus: T_VBVMR_MacroButton_SetStatus,
}
#[test]
fn bindgen_test_layout_tagVBVMR_INTERFACE() {
    const UNINIT: ::std::mem::MaybeUninit<tagVBVMR_INTERFACE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tagVBVMR_INTERFACE>(),
        232usize,
        concat!("Size of: ", stringify!(tagVBVMR_INTERFACE))
    );
    assert_eq!(
        ::std::mem::align_of::<tagVBVMR_INTERFACE>(),
        8usize,
        concat!("Alignment of ", stringify!(tagVBVMR_INTERFACE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VBVMR_Login) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_INTERFACE),
            "::",
            stringify!(VBVMR_Login)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VBVMR_Logout) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_INTERFACE),
            "::",
            stringify!(VBVMR_Logout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VBVMR_RunVoicemeeter) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_INTERFACE),
            "::",
            stringify!(VBVMR_RunVoicemeeter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VBVMR_GetVoicemeeterType) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_INTERFACE),
            "::",
            stringify!(VBVMR_GetVoicemeeterType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VBVMR_GetVoicemeeterVersion) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_INTERFACE),
            "::",
            stringify!(VBVMR_GetVoicemeeterVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VBVMR_IsParametersDirty) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_INTERFACE),
            "::",
            stringify!(VBVMR_IsParametersDirty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VBVMR_GetParameterFloat) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_INTERFACE),
            "::",
            stringify!(VBVMR_GetParameterFloat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VBVMR_GetParameterStringA) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_INTERFACE),
            "::",
            stringify!(VBVMR_GetParameterStringA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VBVMR_GetParameterStringW) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_INTERFACE),
            "::",
            stringify!(VBVMR_GetParameterStringW)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VBVMR_GetLevel) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_INTERFACE),
            "::",
            stringify!(VBVMR_GetLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VBVMR_GetMidiMessage) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_INTERFACE),
            "::",
            stringify!(VBVMR_GetMidiMessage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VBVMR_SetParameterFloat) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_INTERFACE),
            "::",
            stringify!(VBVMR_SetParameterFloat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VBVMR_SetParameters) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_INTERFACE),
            "::",
            stringify!(VBVMR_SetParameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VBVMR_SetParametersW) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_INTERFACE),
            "::",
            stringify!(VBVMR_SetParametersW)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VBVMR_SetParameterStringA) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_INTERFACE),
            "::",
            stringify!(VBVMR_SetParameterStringA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VBVMR_SetParameterStringW) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_INTERFACE),
            "::",
            stringify!(VBVMR_SetParameterStringW)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).VBVMR_Output_GetDeviceNumber) as usize - ptr as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_INTERFACE),
            "::",
            stringify!(VBVMR_Output_GetDeviceNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VBVMR_Output_GetDeviceDescA) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_INTERFACE),
            "::",
            stringify!(VBVMR_Output_GetDeviceDescA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VBVMR_Output_GetDeviceDescW) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_INTERFACE),
            "::",
            stringify!(VBVMR_Output_GetDeviceDescW)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VBVMR_Input_GetDeviceNumber) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_INTERFACE),
            "::",
            stringify!(VBVMR_Input_GetDeviceNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VBVMR_Input_GetDeviceDescA) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_INTERFACE),
            "::",
            stringify!(VBVMR_Input_GetDeviceDescA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VBVMR_Input_GetDeviceDescW) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_INTERFACE),
            "::",
            stringify!(VBVMR_Input_GetDeviceDescW)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VBVMR_AudioCallbackRegister) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_INTERFACE),
            "::",
            stringify!(VBVMR_AudioCallbackRegister)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VBVMR_AudioCallbackStart) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_INTERFACE),
            "::",
            stringify!(VBVMR_AudioCallbackStart)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VBVMR_AudioCallbackStop) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_INTERFACE),
            "::",
            stringify!(VBVMR_AudioCallbackStop)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).VBVMR_AudioCallbackUnregister) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_INTERFACE),
            "::",
            stringify!(VBVMR_AudioCallbackUnregister)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VBVMR_MacroButton_IsDirty) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_INTERFACE),
            "::",
            stringify!(VBVMR_MacroButton_IsDirty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VBVMR_MacroButton_GetStatus) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_INTERFACE),
            "::",
            stringify!(VBVMR_MacroButton_GetStatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VBVMR_MacroButton_SetStatus) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBVMR_INTERFACE),
            "::",
            stringify!(VBVMR_MacroButton_SetStatus)
        )
    );
}
pub type T_VBVMR_INTERFACE = tagVBVMR_INTERFACE;
pub type PT_VBVMR_INTERFACE = *mut tagVBVMR_INTERFACE;
pub type LPT_VBVMR_INTERFACE = *mut tagVBVMR_INTERFACE;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagVBAN_VMRT_PACKET {
    pub voicemeeterType: ::std::os::raw::c_uchar,
    pub reserved: ::std::os::raw::c_uchar,
    pub buffersize: ::std::os::raw::c_ushort,
    pub voicemeeterVersion: ::std::os::raw::c_ulong,
    pub optionBits: ::std::os::raw::c_ulong,
    pub samplerate: ::std::os::raw::c_ulong,
    pub inputLeveldB100: [::std::os::raw::c_short; 34usize],
    pub outputLeveldB100: [::std::os::raw::c_short; 64usize],
    pub TransportBit: ::std::os::raw::c_ulong,
    pub stripState: [::std::os::raw::c_ulong; 8usize],
    pub busState: [::std::os::raw::c_ulong; 8usize],
    pub stripGaindB100Layer1: [::std::os::raw::c_short; 8usize],
    pub stripGaindB100Layer2: [::std::os::raw::c_short; 8usize],
    pub stripGaindB100Layer3: [::std::os::raw::c_short; 8usize],
    pub stripGaindB100Layer4: [::std::os::raw::c_short; 8usize],
    pub stripGaindB100Layer5: [::std::os::raw::c_short; 8usize],
    pub stripGaindB100Layer6: [::std::os::raw::c_short; 8usize],
    pub stripGaindB100Layer7: [::std::os::raw::c_short; 8usize],
    pub stripGaindB100Layer8: [::std::os::raw::c_short; 8usize],
    pub busGaindB100: [::std::os::raw::c_short; 8usize],
    pub stripLabelUTF8c60: [[::std::os::raw::c_char; 60usize]; 8usize],
    pub busLabelUTF8c60: [[::std::os::raw::c_char; 60usize]; 8usize],
}
#[test]
fn bindgen_test_layout_tagVBAN_VMRT_PACKET() {
    const UNINIT: ::std::mem::MaybeUninit<tagVBAN_VMRT_PACKET> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tagVBAN_VMRT_PACKET>(),
        1384usize,
        concat!("Size of: ", stringify!(tagVBAN_VMRT_PACKET))
    );
    assert_eq!(
        ::std::mem::align_of::<tagVBAN_VMRT_PACKET>(),
        1usize,
        concat!("Alignment of ", stringify!(tagVBAN_VMRT_PACKET))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).voicemeeterType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBAN_VMRT_PACKET),
            "::",
            stringify!(voicemeeterType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBAN_VMRT_PACKET),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffersize) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBAN_VMRT_PACKET),
            "::",
            stringify!(buffersize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).voicemeeterVersion) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBAN_VMRT_PACKET),
            "::",
            stringify!(voicemeeterVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optionBits) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBAN_VMRT_PACKET),
            "::",
            stringify!(optionBits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samplerate) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBAN_VMRT_PACKET),
            "::",
            stringify!(samplerate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputLeveldB100) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBAN_VMRT_PACKET),
            "::",
            stringify!(inputLeveldB100)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputLeveldB100) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBAN_VMRT_PACKET),
            "::",
            stringify!(outputLeveldB100)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TransportBit) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBAN_VMRT_PACKET),
            "::",
            stringify!(TransportBit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stripState) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBAN_VMRT_PACKET),
            "::",
            stringify!(stripState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).busState) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBAN_VMRT_PACKET),
            "::",
            stringify!(busState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stripGaindB100Layer1) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBAN_VMRT_PACKET),
            "::",
            stringify!(stripGaindB100Layer1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stripGaindB100Layer2) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBAN_VMRT_PACKET),
            "::",
            stringify!(stripGaindB100Layer2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stripGaindB100Layer3) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBAN_VMRT_PACKET),
            "::",
            stringify!(stripGaindB100Layer3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stripGaindB100Layer4) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBAN_VMRT_PACKET),
            "::",
            stringify!(stripGaindB100Layer4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stripGaindB100Layer5) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBAN_VMRT_PACKET),
            "::",
            stringify!(stripGaindB100Layer5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stripGaindB100Layer6) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBAN_VMRT_PACKET),
            "::",
            stringify!(stripGaindB100Layer6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stripGaindB100Layer7) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBAN_VMRT_PACKET),
            "::",
            stringify!(stripGaindB100Layer7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stripGaindB100Layer8) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBAN_VMRT_PACKET),
            "::",
            stringify!(stripGaindB100Layer8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).busGaindB100) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBAN_VMRT_PACKET),
            "::",
            stringify!(busGaindB100)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stripLabelUTF8c60) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBAN_VMRT_PACKET),
            "::",
            stringify!(stripLabelUTF8c60)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).busLabelUTF8c60) as usize - ptr as usize },
        904usize,
        concat!(
            "Offset of field: ",
            stringify!(tagVBAN_VMRT_PACKET),
            "::",
            stringify!(busLabelUTF8c60)
        )
    );
}
pub type T_VBAN_VMRT_PACKET = tagVBAN_VMRT_PACKET;
pub type PT_VBAN_VMRT_PACKET = *mut tagVBAN_VMRT_PACKET;
pub type LPT_VBAN_VMRT_PACKET = *mut tagVBAN_VMRT_PACKET;
impl VMRTSTATE_MODE {
    pub const MUTE: VMRTSTATE_MODE = VMRTSTATE_MODE(1);
}
impl VMRTSTATE_MODE {
    pub const SOLO: VMRTSTATE_MODE = VMRTSTATE_MODE(2);
}
impl VMRTSTATE_MODE {
    pub const MONO: VMRTSTATE_MODE = VMRTSTATE_MODE(4);
}
impl VMRTSTATE_MODE {
    pub const MUTEC: VMRTSTATE_MODE = VMRTSTATE_MODE(8);
}
impl VMRTSTATE_MODE {
    pub const MIXDOWN: VMRTSTATE_MODE = VMRTSTATE_MODE(16);
}
impl VMRTSTATE_MODE {
    pub const REPEAT: VMRTSTATE_MODE = VMRTSTATE_MODE(32);
}
impl VMRTSTATE_MODE {
    pub const MIXDOWNB: VMRTSTATE_MODE = VMRTSTATE_MODE(48);
}
impl VMRTSTATE_MODE {
    pub const COMPOSITE: VMRTSTATE_MODE = VMRTSTATE_MODE(64);
}
impl VMRTSTATE_MODE {
    pub const UPMIXTV: VMRTSTATE_MODE = VMRTSTATE_MODE(80);
}
impl VMRTSTATE_MODE {
    pub const UPMIX2: VMRTSTATE_MODE = VMRTSTATE_MODE(96);
}
impl VMRTSTATE_MODE {
    pub const UPMIX4: VMRTSTATE_MODE = VMRTSTATE_MODE(112);
}
impl VMRTSTATE_MODE {
    pub const UPMIX6: VMRTSTATE_MODE = VMRTSTATE_MODE(128);
}
impl VMRTSTATE_MODE {
    pub const CENTER: VMRTSTATE_MODE = VMRTSTATE_MODE(144);
}
impl VMRTSTATE_MODE {
    pub const LFE: VMRTSTATE_MODE = VMRTSTATE_MODE(160);
}
impl VMRTSTATE_MODE {
    pub const REAR: VMRTSTATE_MODE = VMRTSTATE_MODE(176);
}
impl VMRTSTATE_MODE {
    pub const MASK: VMRTSTATE_MODE = VMRTSTATE_MODE(240);
}
impl VMRTSTATE_MODE {
    pub const EQ: VMRTSTATE_MODE = VMRTSTATE_MODE(256);
}
impl VMRTSTATE_MODE {
    pub const CROSS: VMRTSTATE_MODE = VMRTSTATE_MODE(512);
}
impl VMRTSTATE_MODE {
    pub const EQB: VMRTSTATE_MODE = VMRTSTATE_MODE(2048);
}
impl VMRTSTATE_MODE {
    pub const BUSA: VMRTSTATE_MODE = VMRTSTATE_MODE(4096);
}
impl VMRTSTATE_MODE {
    pub const BUSA1: VMRTSTATE_MODE = VMRTSTATE_MODE(4096);
}
impl VMRTSTATE_MODE {
    pub const BUSA2: VMRTSTATE_MODE = VMRTSTATE_MODE(8192);
}
impl VMRTSTATE_MODE {
    pub const BUSA3: VMRTSTATE_MODE = VMRTSTATE_MODE(16384);
}
impl VMRTSTATE_MODE {
    pub const BUSA4: VMRTSTATE_MODE = VMRTSTATE_MODE(32768);
}
impl VMRTSTATE_MODE {
    pub const BUSA5: VMRTSTATE_MODE = VMRTSTATE_MODE(524288);
}
impl VMRTSTATE_MODE {
    pub const BUSB: VMRTSTATE_MODE = VMRTSTATE_MODE(65536);
}
impl VMRTSTATE_MODE {
    pub const BUSB1: VMRTSTATE_MODE = VMRTSTATE_MODE(65536);
}
impl VMRTSTATE_MODE {
    pub const BUSB2: VMRTSTATE_MODE = VMRTSTATE_MODE(131072);
}
impl VMRTSTATE_MODE {
    pub const BUSB3: VMRTSTATE_MODE = VMRTSTATE_MODE(262144);
}
impl VMRTSTATE_MODE {
    pub const PAN0: VMRTSTATE_MODE = VMRTSTATE_MODE(0);
}
impl VMRTSTATE_MODE {
    pub const PANCOLOR: VMRTSTATE_MODE = VMRTSTATE_MODE(1048576);
}
impl VMRTSTATE_MODE {
    pub const PANMOD: VMRTSTATE_MODE = VMRTSTATE_MODE(2097152);
}
impl VMRTSTATE_MODE {
    pub const PANMASK: VMRTSTATE_MODE = VMRTSTATE_MODE(15728640);
}
impl VMRTSTATE_MODE {
    pub const POSTFX_R: VMRTSTATE_MODE = VMRTSTATE_MODE(16777216);
}
impl VMRTSTATE_MODE {
    pub const POSTFX_D: VMRTSTATE_MODE = VMRTSTATE_MODE(33554432);
}
impl VMRTSTATE_MODE {
    pub const POSTFX1: VMRTSTATE_MODE = VMRTSTATE_MODE(67108864);
}
impl VMRTSTATE_MODE {
    pub const POSTFX2: VMRTSTATE_MODE = VMRTSTATE_MODE(134217728);
}
impl VMRTSTATE_MODE {
    pub const SEL: VMRTSTATE_MODE = VMRTSTATE_MODE(268435456);
}
impl VMRTSTATE_MODE {
    pub const MONITOR: VMRTSTATE_MODE = VMRTSTATE_MODE(536870912);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct VMRTSTATE_MODE(pub ::std::os::raw::c_int);
extern crate libloading;
pub struct VoicemeeterRemoteRaw {
    __library: ::libloading::Library,
    pub VBVMR_Login: unsafe extern "stdcall" fn() -> ::std::os::raw::c_long,
    pub VBVMR_Logout: unsafe extern "stdcall" fn() -> ::std::os::raw::c_long,
    pub VBVMR_RunVoicemeeter:
        unsafe extern "stdcall" fn(vType: ::std::os::raw::c_long) -> ::std::os::raw::c_long,
    pub VBVMR_GetVoicemeeterType:
        unsafe extern "stdcall" fn(pType: *mut ::std::os::raw::c_long) -> ::std::os::raw::c_long,
    pub VBVMR_GetVoicemeeterVersion:
        unsafe extern "stdcall" fn(pVersion: *mut ::std::os::raw::c_long) -> ::std::os::raw::c_long,
    pub VBVMR_IsParametersDirty: unsafe extern "stdcall" fn() -> ::std::os::raw::c_long,
    pub VBVMR_GetParameterFloat: unsafe extern "stdcall" fn(
        szParamName: *mut ::std::os::raw::c_char,
        pValue: *mut f32,
    ) -> ::std::os::raw::c_long,
    pub VBVMR_GetParameterStringA: unsafe extern "stdcall" fn(
        szParamName: *mut ::std::os::raw::c_char,
        szString: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long,
    pub VBVMR_GetParameterStringW: unsafe extern "stdcall" fn(
        szParamName: *mut ::std::os::raw::c_char,
        wszString: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_long,
    pub VBVMR_GetLevel: unsafe extern "stdcall" fn(
        nType: ::std::os::raw::c_long,
        nuChannel: ::std::os::raw::c_long,
        pValue: *mut f32,
    ) -> ::std::os::raw::c_long,
    pub VBVMR_GetMidiMessage: unsafe extern "stdcall" fn(
        pMIDIBuffer: *mut ::std::os::raw::c_uchar,
        nbByteMax: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long,
    pub VBVMR_SetParameterFloat: unsafe extern "stdcall" fn(
        szParamName: *mut ::std::os::raw::c_char,
        Value: f32,
    ) -> ::std::os::raw::c_long,
    pub VBVMR_SetParameterStringA: unsafe extern "stdcall" fn(
        szParamName: *mut ::std::os::raw::c_char,
        szString: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long,
    pub VBVMR_SetParameterStringW: unsafe extern "stdcall" fn(
        szParamName: *mut ::std::os::raw::c_char,
        wszString: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_long,
    pub VBVMR_SetParameters: unsafe extern "stdcall" fn(
        szParamScript: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long,
    pub VBVMR_SetParametersW: unsafe extern "stdcall" fn(
        szParamScript: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_long,
    pub VBVMR_Output_GetDeviceNumber: unsafe extern "stdcall" fn() -> ::std::os::raw::c_long,
    pub VBVMR_Output_GetDeviceDescA: unsafe extern "stdcall" fn(
        zindex: ::std::os::raw::c_long,
        nType: *mut ::std::os::raw::c_long,
        szDeviceName: *mut ::std::os::raw::c_char,
        szHardwareId: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long,
    pub VBVMR_Output_GetDeviceDescW: unsafe extern "stdcall" fn(
        zindex: ::std::os::raw::c_long,
        nType: *mut ::std::os::raw::c_long,
        wszDeviceName: *mut ::std::os::raw::c_ushort,
        wszHardwareId: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_long,
    pub VBVMR_Input_GetDeviceNumber: unsafe extern "stdcall" fn() -> ::std::os::raw::c_long,
    pub VBVMR_Input_GetDeviceDescA: unsafe extern "stdcall" fn(
        zindex: ::std::os::raw::c_long,
        nType: *mut ::std::os::raw::c_long,
        szDeviceName: *mut ::std::os::raw::c_char,
        szHardwareId: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long,
    pub VBVMR_Input_GetDeviceDescW: unsafe extern "stdcall" fn(
        zindex: ::std::os::raw::c_long,
        nType: *mut ::std::os::raw::c_long,
        wszDeviceName: *mut ::std::os::raw::c_ushort,
        wszHardwareId: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_long,
    pub VBVMR_AudioCallbackRegister: unsafe extern "stdcall" fn(
        mode: ::std::os::raw::c_long,
        pCallback: T_VBVMR_VBAUDIOCALLBACK,
        lpUser: *mut ::std::os::raw::c_void,
        szClientName: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long,
    pub VBVMR_AudioCallbackStart: unsafe extern "stdcall" fn() -> ::std::os::raw::c_long,
    pub VBVMR_AudioCallbackStop: unsafe extern "stdcall" fn() -> ::std::os::raw::c_long,
    pub VBVMR_AudioCallbackUnregister: unsafe extern "stdcall" fn() -> ::std::os::raw::c_long,
    pub VBVMR_MacroButton_IsDirty: unsafe extern "stdcall" fn() -> ::std::os::raw::c_long,
    pub VBVMR_MacroButton_GetStatus: unsafe extern "stdcall" fn(
        nuLogicalButton: ::std::os::raw::c_long,
        pValue: *mut f32,
        bitmode: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long,
    pub VBVMR_MacroButton_SetStatus: unsafe extern "stdcall" fn(
        nuLogicalButton: ::std::os::raw::c_long,
        fValue: f32,
        bitmode: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long,
}
impl VoicemeeterRemoteRaw {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let VBVMR_Login = __library.get(b"VBVMR_Login\0").map(|sym| *sym)?;
        let VBVMR_Logout = __library.get(b"VBVMR_Logout\0").map(|sym| *sym)?;
        let VBVMR_RunVoicemeeter = __library.get(b"VBVMR_RunVoicemeeter\0").map(|sym| *sym)?;
        let VBVMR_GetVoicemeeterType = __library
            .get(b"VBVMR_GetVoicemeeterType\0")
            .map(|sym| *sym)?;
        let VBVMR_GetVoicemeeterVersion = __library
            .get(b"VBVMR_GetVoicemeeterVersion\0")
            .map(|sym| *sym)?;
        let VBVMR_IsParametersDirty = __library
            .get(b"VBVMR_IsParametersDirty\0")
            .map(|sym| *sym)?;
        let VBVMR_GetParameterFloat = __library
            .get(b"VBVMR_GetParameterFloat\0")
            .map(|sym| *sym)?;
        let VBVMR_GetParameterStringA = __library
            .get(b"VBVMR_GetParameterStringA\0")
            .map(|sym| *sym)?;
        let VBVMR_GetParameterStringW = __library
            .get(b"VBVMR_GetParameterStringW\0")
            .map(|sym| *sym)?;
        let VBVMR_GetLevel = __library.get(b"VBVMR_GetLevel\0").map(|sym| *sym)?;
        let VBVMR_GetMidiMessage = __library.get(b"VBVMR_GetMidiMessage\0").map(|sym| *sym)?;
        let VBVMR_SetParameterFloat = __library
            .get(b"VBVMR_SetParameterFloat\0")
            .map(|sym| *sym)?;
        let VBVMR_SetParameterStringA = __library
            .get(b"VBVMR_SetParameterStringA\0")
            .map(|sym| *sym)?;
        let VBVMR_SetParameterStringW = __library
            .get(b"VBVMR_SetParameterStringW\0")
            .map(|sym| *sym)?;
        let VBVMR_SetParameters = __library.get(b"VBVMR_SetParameters\0").map(|sym| *sym)?;
        let VBVMR_SetParametersW = __library.get(b"VBVMR_SetParametersW\0").map(|sym| *sym)?;
        let VBVMR_Output_GetDeviceNumber = __library
            .get(b"VBVMR_Output_GetDeviceNumber\0")
            .map(|sym| *sym)?;
        let VBVMR_Output_GetDeviceDescA = __library
            .get(b"VBVMR_Output_GetDeviceDescA\0")
            .map(|sym| *sym)?;
        let VBVMR_Output_GetDeviceDescW = __library
            .get(b"VBVMR_Output_GetDeviceDescW\0")
            .map(|sym| *sym)?;
        let VBVMR_Input_GetDeviceNumber = __library
            .get(b"VBVMR_Input_GetDeviceNumber\0")
            .map(|sym| *sym)?;
        let VBVMR_Input_GetDeviceDescA = __library
            .get(b"VBVMR_Input_GetDeviceDescA\0")
            .map(|sym| *sym)?;
        let VBVMR_Input_GetDeviceDescW = __library
            .get(b"VBVMR_Input_GetDeviceDescW\0")
            .map(|sym| *sym)?;
        let VBVMR_AudioCallbackRegister = __library
            .get(b"VBVMR_AudioCallbackRegister\0")
            .map(|sym| *sym)?;
        let VBVMR_AudioCallbackStart = __library
            .get(b"VBVMR_AudioCallbackStart\0")
            .map(|sym| *sym)?;
        let VBVMR_AudioCallbackStop = __library
            .get(b"VBVMR_AudioCallbackStop\0")
            .map(|sym| *sym)?;
        let VBVMR_AudioCallbackUnregister = __library
            .get(b"VBVMR_AudioCallbackUnregister\0")
            .map(|sym| *sym)?;
        let VBVMR_MacroButton_IsDirty = __library
            .get(b"VBVMR_MacroButton_IsDirty\0")
            .map(|sym| *sym)?;
        let VBVMR_MacroButton_GetStatus = __library
            .get(b"VBVMR_MacroButton_GetStatus\0")
            .map(|sym| *sym)?;
        let VBVMR_MacroButton_SetStatus = __library
            .get(b"VBVMR_MacroButton_SetStatus\0")
            .map(|sym| *sym)?;
        Ok(VoicemeeterRemoteRaw {
            __library,
            VBVMR_Login,
            VBVMR_Logout,
            VBVMR_RunVoicemeeter,
            VBVMR_GetVoicemeeterType,
            VBVMR_GetVoicemeeterVersion,
            VBVMR_IsParametersDirty,
            VBVMR_GetParameterFloat,
            VBVMR_GetParameterStringA,
            VBVMR_GetParameterStringW,
            VBVMR_GetLevel,
            VBVMR_GetMidiMessage,
            VBVMR_SetParameterFloat,
            VBVMR_SetParameterStringA,
            VBVMR_SetParameterStringW,
            VBVMR_SetParameters,
            VBVMR_SetParametersW,
            VBVMR_Output_GetDeviceNumber,
            VBVMR_Output_GetDeviceDescA,
            VBVMR_Output_GetDeviceDescW,
            VBVMR_Input_GetDeviceNumber,
            VBVMR_Input_GetDeviceDescA,
            VBVMR_Input_GetDeviceDescW,
            VBVMR_AudioCallbackRegister,
            VBVMR_AudioCallbackStart,
            VBVMR_AudioCallbackStop,
            VBVMR_AudioCallbackUnregister,
            VBVMR_MacroButton_IsDirty,
            VBVMR_MacroButton_GetStatus,
            VBVMR_MacroButton_SetStatus,
        })
    }
    #[doc = "@brief Open Communication Pipe With Voicemeeter (typically called on software startup).\n@return :\t 0: OK (no error).\n1: OK but Voicemeeter Application not launched.\n-1: cannot get client (unexpected)\n-2: unexpected login (logout was expected before)."]
    pub unsafe fn VBVMR_Login(&self) -> ::std::os::raw::c_long {
        (self.VBVMR_Login)()
    }
    #[doc = "@brief Close Communication Pipe With Voicemeeter (typically called on software end).\n@return : 0 if ok."]
    pub unsafe fn VBVMR_Logout(&self) -> ::std::os::raw::c_long {
        (self.VBVMR_Logout)()
    }
    #[doc = "@brief Run Voicemeeter Application (get installation directory and run Voicemeeter Application).\n@param vType : Voicemeeter type  (1 = Voicemeeter, 2= Voicemeeter Banana, 3= Voicemeeter Potato, 6 = Potato x64 bits).\n@return :\t 0: Ok.\n-1: not installed (UninstallString not found in registry).\n-2: unknown vType number"]
    pub unsafe fn VBVMR_RunVoicemeeter(
        &self,
        vType: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long {
        (self.VBVMR_RunVoicemeeter)(vType)
    }
    #[doc = "@brief Get Voicemeeter Type\n@param pType : Pointer on 32bit long receiving the type (1 = Voicemeeter, 2= Voicemeeter Banana, 3 Potato).\n\nVOICEMEETER STRIP/BUS INDEX ASSIGNMENT\n\n| Strip 1 | Strip 2 |Virtual Input|  BUS A  |  BUS B  |\n+---------+---------+-------------+---------+---------+\n|    0    |    1    |      2      |    0    |    1    |\n\nVOICEMEETER BANANA STRIP/BUS INDEX ASSIGNMENT\n\n| Strip 1 | Strip 2 | Strip 2 |Virtual Input|Virtual AUX|BUS A1|BUS A2|BUS A3|BUS B1|BUS B2|\n+---------+---------+---------+-------------+-----------+------+------+------+------+------+\n|    0    |    1    |    2    |       3     |     4     |   0  |   1  |   2  |   3  |   4  |\n\nVOICEMEETER POTATO STRIP/BUS INDEX ASSIGNMENT\n\n| Strip 1 | Strip 2 | Strip 2 | Strip 2 | Strip 2 |Virtual Input|Virtual AUX|   VAIO3   |BUS A1|BUS A2|BUS A3|BUS A4|BUS A5|BUS B1|BUS B2|BUS B3|\n+---------+---------+---------+---------+---------+-------------+-----------+-----------+------+------+------+------+------+------+------+------+\n|    0    |    1    |    2    |    3    |    4    |      5      |     6     |     7     |   0  |   1  |   2  |   3  |   4  |   5  |   6  |   7  |\n\n\n@return :\t 0: OK (no error).\n-1: cannot get client (unexpected)\n-2: no server."]
    pub unsafe fn VBVMR_GetVoicemeeterType(
        &self,
        pType: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long {
        (self.VBVMR_GetVoicemeeterType)(pType)
    }
    #[doc = "@brief Get Voicemeeter Version\n@param pType : Pointer on 32bit integer receiving the version (v1.v2.v3.v4)\nv1 = (version & 0xFF000000)>>24;\nv2 = (version & 0x00FF0000)>>16;\nv3 = (version & 0x0000FF00)>>8;\nv4 = version & 0x000000FF;\n\n@return :\t 0: OK (no error).\n-1: cannot get client (unexpected)\n-2: no server."]
    pub unsafe fn VBVMR_GetVoicemeeterVersion(
        &self,
        pVersion: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long {
        (self.VBVMR_GetVoicemeeterVersion)(pVersion)
    }
    #[doc = "@brief  Check if parameters have changed.\nCall this function periodically (typically every 10 or 20ms).\n(this function must be called from one thread only)\n\n@return:\t 0: no new paramters.\n1: New parameters -> update your display.\n-1: error (unexpected)\n-2: no server."]
    pub unsafe fn VBVMR_IsParametersDirty(&self) -> ::std::os::raw::c_long {
        (self.VBVMR_IsParametersDirty)()
    }
    #[doc = "@brief get parameter value.\n@param szParamName : Null Terminal ASCII String giving the name of the parameter (see parameters name table)\n@param pValue : Pointer on float (32bit float by reference) receiving the wanted value.\n@return :\t 0: OK (no error).\n-1: error\n-2: no server.\n-3: unknown parameter\n-5: structure mismatch"]
    pub unsafe fn VBVMR_GetParameterFloat(
        &self,
        szParamName: *mut ::std::os::raw::c_char,
        pValue: *mut f32,
    ) -> ::std::os::raw::c_long {
        (self.VBVMR_GetParameterFloat)(szParamName, pValue)
    }
    #[doc = "@brief get parameter value.\n@param szParamName : Null Terminal ASCII String giving the name of the parameter (see parameters name table)\n@param pValue : Pointer on String (512 char or wchar) receiving the wanted value.\n@return :\t 0: OK (no error).\n-1: error\n-2: no server.\n-3: unknown parameter\n-5: structure mismatch"]
    pub unsafe fn VBVMR_GetParameterStringA(
        &self,
        szParamName: *mut ::std::os::raw::c_char,
        szString: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long {
        (self.VBVMR_GetParameterStringA)(szParamName, szString)
    }
    pub unsafe fn VBVMR_GetParameterStringW(
        &self,
        szParamName: *mut ::std::os::raw::c_char,
        wszString: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_long {
        (self.VBVMR_GetParameterStringW)(szParamName, wszString)
    }
    #[doc = "@brief Get Current levels.\n(this function must be called from one thread only)\n\n@param nType:\t0= pre fader input levels.\n1= post fader input levels.\n2= post Mute input levels.\n3= output levels.\n\n@param nuChannel: audio channel zero based index\nfor input 0 = in#1 left, 1= in#1 Right, etc...\nfor output 0 = busA ch1, 1 = busA ch2...\n\nVOICEMEETER CHANNEL ASSIGNMENT\n\n| Strip 1 | Strip 2 |             Virtual Input             |\n+----+----+----+----+----+----+----+----+----+----+----+----+\n| 00 | 01 | 02 | 03 | 04 | 05 | 06 | 07 | 08 | 09 | 10 | 11 |\n\n|             Output A1 / A2            |             Virtual Output            |\n+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n| 00 | 01 | 02 | 03 | 04 | 05 | 06 | 07 | 08 | 09 | 10 | 11 | 12 | 13 | 14 | 15 |\n\nVOICEMEETER BANANA CHANNEL ASSIGNMENT\n\n| Strip 1 | Strip 2 | Strip 3 |             Virtual Input             |            Virtual Input AUX          |\n+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n| 00 | 01 | 02 | 03 | 04 | 05 | 06 | 07 | 08 | 09 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 |\n\n|             Output A1                 |                Output A2              |                Output A3              |\n+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n| 00 | 01 | 02 | 03 | 04 | 05 | 06 | 07 | 08 | 09 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 |\n\n|            Virtual Output B1          |             Virtual Output B2         |\n+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n| 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 39 |\n\nVOICEMEETER POTATO CHANNEL ASSIGNMENT\n\n| Strip 1 | Strip 2 | Strip 3 | Strip 4 | Strip 5 |             Virtual Input             |            Virtual Input AUX          |                 VAIO3                 |\n+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n| 00 | 01 | 02 | 03 | 04 | 05 | 06 | 07 | 08 | 09 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 25 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 |\n\n|             Output A1                 |                Output A2              |                Output A3              |                Output A4              |                Output A5              |\n+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n| 00 | 01 | 02 | 03 | 04 | 05 | 06 | 07 | 08 | 09 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 39 |\n\n|            Virtual Output B1          |             Virtual Output B2         |             Virtual Output B3         |\n+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n| 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 58 | 59 | 60 | 61 | 62 | 63 |\n\n\n@return :\t 0: OK (no error).\n-1: error\n-2: no server.\n-3: no level available\n-4: out of range"]
    pub unsafe fn VBVMR_GetLevel(
        &self,
        nType: ::std::os::raw::c_long,
        nuChannel: ::std::os::raw::c_long,
        pValue: *mut f32,
    ) -> ::std::os::raw::c_long {
        (self.VBVMR_GetLevel)(nType, nuChannel, pValue)
    }
    #[doc = "@brief Get MIDI message from M.I.D.I. input device used by Voicemeeter M.I.D.I. mapping.\n(this function must be called from one thread only)\n\n@param pMIDIBuffer:\tpointer on MIDI Buffer. Expected message size is below 4 bytes,\nbut it's recommended to use 1024 Bytes local buffer to receive\npossible multiple M.I.D.I. event message in optimal way:\nunsigned char pBuffer[1024];\n\n\n@return :\t>0: number of bytes placed in buffer (2 or 3 byte for usual M.I.D.I. message)\n-1: error\n-2: no server.\n-5: no MIDI data\n-6: no MIDI data"]
    pub unsafe fn VBVMR_GetMidiMessage(
        &self,
        pMIDIBuffer: *mut ::std::os::raw::c_uchar,
        nbByteMax: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long {
        (self.VBVMR_GetMidiMessage)(pMIDIBuffer, nbByteMax)
    }
    #[doc = "@brief Set a single float 32 bits parameters .\n@param szParamName : Null Terminal ASCII String giving the name of the parameter (see parameters name table)\nexample:\nStrip[1].gain\nStrip[0].mute\nBus[0].gain\nBus[0].eq.channel[0].cell[0].gain\n\n@param pValue : float 32bit containing the new value.\n@return :\t 0: OK (no error).\n-1: error\n-2: no server.\n-3: unknown parameter"]
    pub unsafe fn VBVMR_SetParameterFloat(
        &self,
        szParamName: *mut ::std::os::raw::c_char,
        Value: f32,
    ) -> ::std::os::raw::c_long {
        (self.VBVMR_SetParameterFloat)(szParamName, Value)
    }
    #[doc = "@brief Set a single string parameters .\n@param szParamName : Null Terminal ASCII String giving the name of the parameter (see parameters name table)\nexample:\nStrip[1].name\nStrip[0].device.mme\nBus[0].device.asio\n\n@param szString : zero terminal string.\n@return :\t 0: OK (no error).\n-1: error\n-2: no server.\n-3: unknown parameter\n"]
    pub unsafe fn VBVMR_SetParameterStringA(
        &self,
        szParamName: *mut ::std::os::raw::c_char,
        szString: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long {
        (self.VBVMR_SetParameterStringA)(szParamName, szString)
    }
    pub unsafe fn VBVMR_SetParameterStringW(
        &self,
        szParamName: *mut ::std::os::raw::c_char,
        wszString: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_long {
        (self.VBVMR_SetParameterStringW)(szParamName, wszString)
    }
    #[doc = "@brief Set one or several parameters by a script ( < 48 kB ).\n@param szParamName : Null Terminal ASCII String giving the script\n(script allows to change several parameters in the same time - SYNCHRO).\nPossible Instuction separators: ',' ';' or '\\n'(CR)\nEXAMPLE:\n\"Strip[0].gain = -6.0\nStrip[0].A1 = 0\nStrip[0].B1 = 1\nStrip[1].gain = -6.0\nStrip[2].gain = 0.0\nStrip[3].name = \"Skype Caller\" \"\n\n@return :\t 0: OK (no error).\n>0: number of line causing script error.\n-1: error\n-2: no server.\n-3: unexpected error\n-4: unexpected error"]
    pub unsafe fn VBVMR_SetParameters(
        &self,
        szParamScript: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long {
        (self.VBVMR_SetParameters)(szParamScript)
    }
    pub unsafe fn VBVMR_SetParametersW(
        &self,
        szParamScript: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_long {
        (self.VBVMR_SetParametersW)(szParamScript)
    }
    #[doc = "@brief Get number of Audio Output Device available on the system\n@return : return number of device found."]
    pub unsafe fn VBVMR_Output_GetDeviceNumber(&self) -> ::std::os::raw::c_long {
        (self.VBVMR_Output_GetDeviceNumber)()
    }
    #[doc = "@brief Return pointer on Output Device Descriptor according index\n@param zindex : zero based index\n@param nType : Pointer on 32bit long receiving the type (pointer can be NULL).\n@param szName : Pointer on string (256 char min) receiving the device name (pointer can be NULL).\n@param szHardwareId : Pointer on string (256 char min) receiving the hardware ID (pointer can be NULL).\n@return :\t 0: OK (no error)."]
    pub unsafe fn VBVMR_Output_GetDeviceDescA(
        &self,
        zindex: ::std::os::raw::c_long,
        nType: *mut ::std::os::raw::c_long,
        szDeviceName: *mut ::std::os::raw::c_char,
        szHardwareId: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long {
        (self.VBVMR_Output_GetDeviceDescA)(zindex, nType, szDeviceName, szHardwareId)
    }
    pub unsafe fn VBVMR_Output_GetDeviceDescW(
        &self,
        zindex: ::std::os::raw::c_long,
        nType: *mut ::std::os::raw::c_long,
        wszDeviceName: *mut ::std::os::raw::c_ushort,
        wszHardwareId: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_long {
        (self.VBVMR_Output_GetDeviceDescW)(zindex, nType, wszDeviceName, wszHardwareId)
    }
    #[doc = "@brief Get number of Audio Input Device available on the system\n@return : return number of device found."]
    pub unsafe fn VBVMR_Input_GetDeviceNumber(&self) -> ::std::os::raw::c_long {
        (self.VBVMR_Input_GetDeviceNumber)()
    }
    #[doc = "@brief Return pointer on Input Device Descriptor according index\n@param zindex : zero based index\n@param nType : Pointer on 32bit long receiving the type (pointer can be NULL).\n@param szName : Pointer on string (256 char min) receiving the device name (pointer can be NULL).\n@param szHardwareId : Pointer on string (256 char min) receiving the hardware ID (pointer can be NULL).\n@return :\t 0: OK (no error)."]
    pub unsafe fn VBVMR_Input_GetDeviceDescA(
        &self,
        zindex: ::std::os::raw::c_long,
        nType: *mut ::std::os::raw::c_long,
        szDeviceName: *mut ::std::os::raw::c_char,
        szHardwareId: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long {
        (self.VBVMR_Input_GetDeviceDescA)(zindex, nType, szDeviceName, szHardwareId)
    }
    pub unsafe fn VBVMR_Input_GetDeviceDescW(
        &self,
        zindex: ::std::os::raw::c_long,
        nType: *mut ::std::os::raw::c_long,
        wszDeviceName: *mut ::std::os::raw::c_ushort,
        wszHardwareId: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_long {
        (self.VBVMR_Input_GetDeviceDescW)(zindex, nType, wszDeviceName, wszHardwareId)
    }
    #[doc = "@brief register your audio callback function to receive real time audio buffer\nit's possible to register up to 3x different Audio Callback in the same application or in\n3x different applications. In the same application, this is possible because Voicemeeter\nprovides 3 kind of audio Streams:\n- AUDIO INPUT INSERT (to process all Voicemeeter inputs as insert)\n- AUDIO OUTPUT INSERT (to process all Voicemeeter BUS outputs as insert)\n- ALL AUDIO I/O (to process all Voicemeeter i/o).\nNote: a single callback can be used to receive the 3 possible audio streams.\n\n@param mode : callback type (main, input or bus output) see define below\n@param pCallback : Pointer on your callback function.\n@param lpUser : user pointer (pointer that will be passed in callback first argument).\n@param szClientName[64]: IN: Name of the application registering the Callback.\nOUT: Name of the application already registered.\n@return :\t 0: OK (no error).\n-1: error\n1: callback already registered (by another application)."]
    pub unsafe fn VBVMR_AudioCallbackRegister(
        &self,
        mode: ::std::os::raw::c_long,
        pCallback: T_VBVMR_VBAUDIOCALLBACK,
        lpUser: *mut ::std::os::raw::c_void,
        szClientName: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long {
        (self.VBVMR_AudioCallbackRegister)(mode, pCallback, lpUser, szClientName)
    }
    #[doc = "@brief\tStart / Stop Audio processing\n\nhe Callback will be called with\n@return :\t 0: OK (no error).\n-1: error\n-2: no callback registred."]
    pub unsafe fn VBVMR_AudioCallbackStart(&self) -> ::std::os::raw::c_long {
        (self.VBVMR_AudioCallbackStart)()
    }
    pub unsafe fn VBVMR_AudioCallbackStop(&self) -> ::std::os::raw::c_long {
        (self.VBVMR_AudioCallbackStop)()
    }
    #[doc = "@brief unregister your callback to release voicemeeter virtual driver\n(this function will automatically call VBVMR_AudioCallbackStop() function)\n@param pCallback : Pointer on your callback function.\n@return :\t 0: OK (no error).\n-1: error\n1: callback already unregistered."]
    pub unsafe fn VBVMR_AudioCallbackUnregister(&self) -> ::std::os::raw::c_long {
        (self.VBVMR_AudioCallbackUnregister)()
    }
    #[doc = "@brief  Check if Macro Buttons states changed.\nCall this function periodically (typically every 50 or 500ms) to know if something happen on MacroButton states .\n(this function must be called from one thread only)\n\n@return:\t 0: no new status.\n>0: last nu logical button status changed.\n-1: error (unexpected)\n-2: no server."]
    pub unsafe fn VBVMR_MacroButton_IsDirty(&self) -> ::std::os::raw::c_long {
        (self.VBVMR_MacroButton_IsDirty)()
    }
    #[doc = "@brief get current status of a given button.\n@param nuLogicalButton : button index: 0 to 79)\n@param pValue : Pointer on float (32bit float by reference) receiving the wanted value (0.0 = OFF / 1.0 = ON).\n@param bitmode: define what kind of value you want to read (see MACROBUTTON_MODE below)\n@return :\t 0: OK (no error).\n-1: error\n-2: no server.\n-3: unknown parameter\n-5: structure mismatch"]
    pub unsafe fn VBVMR_MacroButton_GetStatus(
        &self,
        nuLogicalButton: ::std::os::raw::c_long,
        pValue: *mut f32,
        bitmode: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long {
        (self.VBVMR_MacroButton_GetStatus)(nuLogicalButton, pValue, bitmode)
    }
    #[doc = "@brief set current button value.\n@param nuLogicalButton : button index: 0 to 79)\n@param fValue : float 32 bit value giving the status (0.0 = OFF / 1.0 = ON).\n@param bitmode: define what kind of value you want to write/modify (see MACROBUTTON_MODE below)\n@return :\t 0: OK (no error).\n-1: error\n-2: no server.\n-3: unknown parameter\n-5: structure mismatch"]
    pub unsafe fn VBVMR_MacroButton_SetStatus(
        &self,
        nuLogicalButton: ::std::os::raw::c_long,
        fValue: f32,
        bitmode: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long {
        (self.VBVMR_MacroButton_SetStatus)(nuLogicalButton, fValue, bitmode)
    }
}
